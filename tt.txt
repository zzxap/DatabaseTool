K8S实现了什么？

从架构设计层面，我们关注的可用性，伸缩性都可以结合k8s得到很好的解决，如果你想使用微服务架构，搭配k8s，真的是完美，再从部署运维层面，服务部署，服务监控，应用扩容和故障处理，k8s都提供了很好的解决方案。

具体来说，主要包括以下几点：

服务发现与调度
负载均衡
服务自愈
服务弹性扩容
横向扩容
存储卷挂载
总而言之，k8s可以使我们应用的部署和运维更加方便。


1 内核空间
2 栈(stack)
3 内存映射段(mmap)
4 堆(heap)
5 BSS段
6 数据段(Data)
7 代码段(text)
8 保留区

——linux——】
1.互斥锁
2.条件变量
3.信号量


IPC

1.管道：无名管道是父子间的，有名任意
2.消息队列：快被取代
3.共享内存：
4.信号量
5.信号
6.socket

————————————————
版权声明：本文为CSDN博主「吃不够的圆儿宝」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u012300157/article/details/50832516


网络是不可靠的，有可以最后一个ACK丢失。
所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。
在Client发送出最后的ACK回复，但该ACK可能丢失。
Server如果没有收到ACK，将不断重复发送FIN片段。
所以Client不能立即关闭，它必须确认Server接收到了该ACK。
Client会在发送出ACK之后进入到TIME_WAIT状态。
Client会设置一个计时器，等待2MSL的时间。
如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。
所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。
MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。
如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。


浅拷贝只复制指向某个对象的指针,而不复制对象本身,新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象,新对象跟原对象不共享内存,修改新对象不会改到原对象



func isValid(s string) {
        //假如长度是1或者不为偶数
        if len(s)<2||len(s)%2!=0{
            if s ==nil{
                return true
            }
            else{
                return false
            }
        }
       count := 0
       length :=len(s)
        //循环替换，最大次数为len(s)/2
        while(count<length/2){
            s = s.replace("{}","").replace("[]","").replace("()","");
            count++;
        }
        //假如循环替换完，还有值，那么肯定就不是对称结构
        if(s.length()>0){
             return false;
        }
        else{
             return true;
        }
    }

